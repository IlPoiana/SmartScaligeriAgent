//import distance function
import { distance } from '../../agents/lib/algorithms.js'
import { IntentionRevision } from './intention.js'
/**
 * Class which implements the push method that performs the revise of the intention queue
 */
class IntentionRevisionRevise extends IntentionRevision {

    

    constructor(belief_set) {
        super(belief_set);
        this.belief_set = belief_set;
        this.last_delivery_position = null; // salva la posizione x,y
    }

    parcelRewardFun(predicate) {
        const id_p = predicate[3]
        let parcel = this.belief_set.getParcel(id_p)
        if(!parcel)
            return 0;
        //quando arriva delivery diventa undefined
        // let computed_reward = reward -  distance({x:x1,y:y1},{ x:parcel.data.x, y:parcel.data.y}) / 2;
        let my_position = this.belief_set.me;
        let parcel_position = { x:parcel.data.x, y:parcel.data.y};
        let abs_distance = distance(my_position,parcel_position) > 0 ? distance(my_position,parcel_position) : 1;
        let computed_reward = (1 / (abs_distance * (1000/ settings.movement))) * 1000;
        // console.log("CHECK reward- id:", predicate[3],computed_reward);
        // console.log("CHECK 1",computed_reward, abs_distance, settings.movement);
        return computed_reward < 0 ? 0 : computed_reward;
    }

    rewardFun(predicate){

        switch (predicate[0]) {
            case 'go_pick_up':
                let parcel_reward = (this.belief_set.getParcel(predicate[3])).timedata.elapsed;
                const final_reward = parcelRewardFun(predicate) + parcel_reward
                // console.log("CHECK 2",predicate,parcelRewardFun(predicate, my_position),parcel_reward,final_reward);
                return final_reward > 1 ? final_reward : 2;
                break;
            case 'delivery':
                return predicate[1];
                break;
            case 'wandering':
                return 0;
                break;
            default:
                break;
        }
        
    }

    checkIntention(intention){
        const type = intention.predicate[0];
        switch (type) {
            case 'go_pick_up':
                const parcel_id = intention.predicate[3];
                const reward = rewardFun(intention.predicate)
                if(!this.belief_set.getParcel( parcel_id ) || reward < 1){
                    // console.log(parcels.get(parcel_id), intention.predicate[4]);
                    return true;
                }
                return false;
                break;
            default:
                return false;
                break;
        }
    }

    cleanIntentions() {
        //iterate over the intention queue and delete the intentions for the deceased parcels
        if(this.current_intention && this.checkIntention(this.current_intention)){
            this.current_intention.stop();
            this.current_intention = null; //resetting the current intention
            console.log("stopped current intention");
        }
        this.intention_queue.forEach((intention, index) => {
            if(this.checkIntention(intention)){
                // console.log("CHECK CLEANING: ", intention.predicate,this.current_intention.predicate);
                if(this.current_intention && intention.predicate[3] == this.current_intention.predicate[3]){
                    this.current_intention.stop();
                    console.log("stopping intention: ", intention.predicate);//doesn't work
                }
                    
                this.intention_queue = this.intention_queue.filter((others) => {return others.predicate.join(' ') != intention.predicate.join(' ')});
            }

            //deleting duplicates delivery intentions
            if(index > 0 && intention.predicate[0] == 'delivery' && this.intention_queue[index - 1] && this.intention_queue[index - 1].predicate[0] == 'delivery'){
                this.intention_queue = this.intention_queue.filter((int_to_delete) => {
                    return int_to_delete.predicate.join(' ') != this.intention_queue[index - 1].predicate.join(' ')
                })
            }

        })
    }

    
    async push ( predicate ) {
        const intention_name = predicate[0];
        
        // console.log("pushing",intention_name);
        
        // Check if already queued but not delivery(possible > 2)
        if ( intention_name != 'delivery' && this.intention_queue.find( (i) => i.predicate.join(' ') == predicate.join(' ') ) )
            return; // intention is already queued
        
        if (settings.decay){
            updateElapsed();
            this.cleanIntentions();
        }

        if(this.intention_queue.length == 0){

            this.intention_queue.push(new Intention( this, predicate ));
            
            if(this.belief_set.getParcel(predicate[3])){
                let reward = rewardFun(predicate);
                //leave wandering as soon you detect a parcel
                if(this.current_intention && this.current_intention.predicate[0] == 'wandering'){
                    console.log("switched intention");
                    this.current_intention.stop();
                }
                // console.log("CHECK 0 pushing delivery", reward);
                await this.push(['delivery', Math.round(reward / 2)]);
            }    
            return;
        }


        switch (intention_name) {
            case 'delivery':
                //count the delivery in the queue
                let delivery_in_queue = this.intention_queue.filter((intention) => intention.predicate[0] == 'delivery');
                let last_intention = this.intention_queue[this.intention_queue.length - 1];
                if(last_intention.predicate[0] != 'delivery'){
                    console.log( 'IntentionRevisionReplace.push', predicate );
                    const intention = new Intention( this, predicate );
                    this.intention_queue.push( intention );}
                else{
                    console.log("delivery already scheduled");
                }
                break;
            case 'go_pick_up':
                if(this.belief_set.getParcel(predicate[3])){
                    let delivery_reward = rewardFun(predicate); // >= 1
                    let new_intention = new Intention(this, predicate);
                    this.intention_queue.push(new_intention);

                    //Change the actual intention if I push something better
                    if(this.current_intention && rewardFun(this.current_intention.predicate) < rewardFun(predicate)){
                        const rescheduled_intention = this.current_intention
                        this.current_intention.stop();
                        this.intention_queue.push(rescheduled_intention);
                    }

                    this.intention_queue.sort((a, b) =>{
                        // if(a[3] && b[3])
                        return rewardFun(a.predicate) - rewardFun(b.predicate) 
                        // else return 0;
                    })
                    this.intention_queue.reverse();
                    //leave wandering as soon you detect a parcel or a better parcel than the one that I'm going to pick up
                    if(this.current_intention && this.current_intention.predicate[0] == 'wandering')
                        this.current_intention.stop();

                    const delivery = ['delivery', Math.round(delivery_reward / 2)];
                    await this.push(delivery);
                }
                else
                    console.log("Intention: ", predicate, "no more valid");
                break;
            case 'wandering':
                let wandering_arr = this.intention_queue.filter((intention) => intention.predicate[0] == 'wandering');
                if(wandering_arr.length == 0){
                    console.log("CHECK wandering");
                    let wandering = new Intention(this, ['wandering']);
                    this.intention_queue.push(wandering)
                }
                break;
            default:
                break;
        }
    }

    isValid ( intention ) {
        const my_id = this.belief_set.me.id;
        switch (intention.predicate[0]){
            case 'go_pick_up':
                const parcel = this.belief_set.getParcel(intention.predicate[3])
                return parcel && parcel.carriedBy != my_id; 
                break;
            case 'delivery':
                return this.belief_set.parcels.filter((parcel) => {
                    return parcel.carriedBy == my_id
                }).length != 0;
                break;
            case 'wandering':
                return true;
                break;
        }
    }
}